//// PostgreSQL database service
////
//// Manages a PostgreSQL connection pool using Dream's singleton pattern. The singleton
//// runs as an OTP process, safely sharing the connection across all requests.
////
//// ## Setup
////
//// Create and start the database service in your services initialization:
////
//// ```gleam
//// import dream/services/postgres
//// import pog
////
//// pub fn initialize_services() {
////   // Create connection
////   let db_config = pog.Config(
////     ..pog.default_config(),
////     host: "localhost",
////     database: "myapp",
////     user: "postgres",
////     password: option.Some("password"),
////   )
////   let db = pog.connect(db_config)
////   
////   // Start singleton service
////   let db_name = process.new_name()
////   let assert Ok(_) = postgres.start_with_connection(db_name, db)
////   
////   Services(db: db_name)
//// }
//// ```
////
//// ## Two Ways to Query
////
//// ### Option 1: Direct Queries (Quick and Simple)
////
//// Use `query()` or `execute()` for simple queries:
////
//// ```gleam
//// // SELECT query
//// let result = postgres.query(
////   services.db,
////   "SELECT * FROM users WHERE id = $1",
////   [pog.int(user_id)],
////   timeout: 5000
//// )
////
//// // INSERT/UPDATE/DELETE
//// let result = postgres.execute(
////   services.db,
////   "INSERT INTO users (name, email) VALUES ($1, $2)",
////   [pog.text(name), pog.text(email)],
////   timeout: 5000
//// )
//// ```
////
//// ### Option 2: Type-Safe Queries with Squirrel
////
//// For complex queries or when you want type safety, use Squirrel to generate
//// type-safe query functions, then get the connection:
////
//// ```gleam
//// import app/sql  // Generated by Squirrel
////
//// pub fn get_user(services: Services, id: Int) {
////   case postgres.get_connection(services.db, timeout: 5000) {
////     Ok(conn) -> sql.get_user(conn, id)
////     Error(e) -> Error(e)
////   }
//// }
//// ```
////
//// Squirrel generates functions from your `.sql` files with full type safety.

import dream/core/singleton
import gleam/dynamic
import gleam/dynamic/decode
import gleam/erlang/process
import gleam/list
import gleam/option
import gleam/result
import pog

/// State type for PostgreSQL singleton
pub type PostgresState {
  PostgresState(connection: pog.Connection)
}

/// Message types for PostgreSQL singleton
pub type PostgresMessage {
  Query(sql: String, params: List(pog.Value))
  Execute(sql: String, params: List(pog.Value))
  GetConnection
}

/// Reply types for PostgreSQL singleton
pub type PostgresReply {
  QueryResult(Result(pog.Returned(dynamic.Dynamic), pog.QueryError))
  ExecuteResult(Result(pog.Returned(dynamic.Dynamic), pog.QueryError))
  ConnectionResult(Result(pog.Connection, String))
}

/// Errors that can occur during database operations
pub type PostgresError {
  QueryError(pog.QueryError)
  ConnectionError(String)
  SingletonError(String)
}

/// Start the PostgreSQL service with a connection
///
//// Launches a singleton process to manage the database connection. Call this once
//// during service initialization, not per-request.
////
//// ## Example
////
//// ```gleam
//// let db_config = pog.Config(..pog.default_config(), database: "myapp")
//// let db = pog.connect(db_config)
//// let db_name = process.new_name()
//// let assert Ok(_) = postgres.start_with_connection(db_name, db)
//// ```
pub fn start_with_connection(
  name: process.Name(singleton.SingletonMessage(PostgresMessage, PostgresReply)),
  connection: pog.Connection,
) -> Result(Nil, String) {
  let initial_state = PostgresState(connection: connection)

  singleton.start(name, initial_state, handle_postgres_message)
  |> result.map(fn(_) { Nil })
}

fn handle_postgres_message(
  msg: PostgresMessage,
  state: PostgresState,
) -> #(PostgresState, option.Option(PostgresReply)) {
  case msg {
    Query(sql, params) -> {
      // Build query with parameters
      let query = pog.query(sql)
      let query_with_params =
        list.fold(over: params, from: query, with: fn(acc, param) {
          pog.parameter(acc, param)
        })

      // Execute query with dynamic decoder
      case
        pog.execute(
          pog.returning(query_with_params, decode.dynamic),
          on: state.connection,
        )
      {
        Ok(result) -> #(state, option.Some(QueryResult(Ok(result))))
        Error(e) -> #(state, option.Some(QueryResult(Error(e))))
      }
    }
    Execute(sql, params) -> {
      // Build query with parameters
      let query = pog.query(sql)
      let query_with_params =
        list.fold(over: params, from: query, with: fn(acc, param) {
          pog.parameter(acc, param)
        })

      // Execute query without decoder (for INSERT/UPDATE/DELETE)
      case
        pog.execute(
          pog.returning(query_with_params, decode.dynamic),
          on: state.connection,
        )
      {
        Ok(result) -> #(state, option.Some(ExecuteResult(Ok(result))))
        Error(e) -> #(state, option.Some(ExecuteResult(Error(e))))
      }
    }
    GetConnection -> {
      // Return the connection from state
      #(state, option.Some(ConnectionResult(Ok(state.connection))))
    }
  }
}

/// Execute a SELECT query and return rows
///
//// Use this for queries that return data. Parameters are automatically escaped
//// to prevent SQL injection.
////
//// ## Example
////
//// ```gleam
//// case postgres.query(
////   services.db,
////   "SELECT * FROM users WHERE age > $1",
////   [pog.int(18)],
////   timeout: 5000
//// ) {
////   Ok(result) -> {
////     // Use result.rows with a decoder
////     let users = list.filter_map(result.rows, decode_user)
////     Ok(users)
////   }
////   Error(e) -> Error(e)
//// }
//// ```
pub fn query(
  name: process.Name(singleton.SingletonMessage(PostgresMessage, PostgresReply)),
  sql: String,
  params: List(pog.Value),
  timeout: Int,
) -> Result(pog.Returned(dynamic.Dynamic), PostgresError) {
  case singleton.call(name, Query(sql: sql, params: params), timeout) {
    Ok(QueryResult(Ok(result))) -> Ok(result)
    Ok(QueryResult(Error(e))) -> Error(QueryError(e))
    Ok(_) -> Error(QueryError(pog.UnexpectedResultType([])))
    Error(e) -> Error(SingletonError(e))
  }
}

/// Execute an INSERT, UPDATE, or DELETE statement
///
//// Use this for queries that modify data but don't return rows (or when you
//// don't care about the returned rows).
////
//// ## Example
////
//// ```gleam
//// case postgres.execute(
////   services.db,
////   "INSERT INTO users (name, email) VALUES ($1, $2)",
////   [pog.text("Alice"), pog.text("alice@example.com")],
////   timeout: 5000
//// ) {
////   Ok(_) -> Ok("User created")
////   Error(e) -> Error("Database error")
//// }
//// ```
pub fn execute(
  name: process.Name(singleton.SingletonMessage(PostgresMessage, PostgresReply)),
  sql: String,
  params: List(pog.Value),
  timeout: Int,
) -> Result(pog.Returned(dynamic.Dynamic), PostgresError) {
  case singleton.call(name, Execute(sql: sql, params: params), timeout) {
    Ok(ExecuteResult(Ok(result))) -> Ok(result)
    Ok(ExecuteResult(Error(e))) -> Error(QueryError(e))
    Ok(_) -> Error(QueryError(pog.UnexpectedResultType([])))
    Error(e) -> Error(SingletonError(e))
  }
}

/// Get the raw connection for use with Squirrel
///
//// Retrieve the underlying Pog connection to use with Squirrel-generated
//// query functions. This gives you full type safety for complex queries.
////
//// ## Example
////
//// ```gleam
//// import app/sql  // Generated by Squirrel
////
//// pub fn get_user_posts(services: Services, user_id: Int) {
////   case postgres.get_connection(services.db, timeout: 5000) {
////     Ok(conn) -> {
////       // Use Squirrel-generated functions
////       sql.get_user_posts(conn, user_id)
////     }
////     Error(e) -> Error(e)
////   }
//// }
//// ```
pub fn get_connection(
  name: process.Name(singleton.SingletonMessage(PostgresMessage, PostgresReply)),
  timeout: Int,
) -> Result(pog.Connection, PostgresError) {
  case singleton.call(name, GetConnection, timeout) {
    Ok(ConnectionResult(Ok(connection))) -> Ok(connection)
    Ok(ConnectionResult(Error(e))) -> Error(SingletonError(e))
    Ok(_) -> Error(SingletonError("Unexpected reply type"))
    Error(e) -> Error(SingletonError(e))
  }
}
