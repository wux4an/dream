# Tutorial: Database CRUD Operations

**Time:** 30 minutes  
**Prerequisites:** [Basic Routing](basic-routing.md) completed, PostgreSQL installed  
**Example code:** `src/examples/database/`

Time to connect to a real database. No ORM abstractions hiding what's happening. Just type-safe SQL queries that you can actually read.

We use [Squirrel](https://github.com/giacomocavalieri/squirrel) to generate type-safe Gleam functions from SQL files. You write SQL. Squirrel makes it type-safe. Dream stays out of your way.

## What We're Building

A REST API for users with full CRUD:
- `GET /users` - List all users
- `GET /users/:id` - Get one user
- `POST /users` - Create a user
- `PUT /users/:id` - Update a user
- `DELETE /users/:id` - Delete a user

With JSON validation, proper error handling, and type safety from database to JSON response.

## Prerequisites: Database Setup

First, start PostgreSQL:

```bash
make db-up
```

This starts PostgreSQL in Docker at `localhost:5434`. Run migrations:

```bash
make migrate
```

This creates your `users` table. Now let's build the API.

## Project Structure

```
src/
  your_app/
    controllers/
      users_controller.gleam
    models/
      user.gleam
    sql/
      list_users.sql
      get_user.sql
      create_user.sql
      update_user.sql
      delete_user.sql
    context.gleam
    database.gleam
    main.gleam
    router.gleam
    services.gleam
    sql.gleam  # Generated by Squirrel
```

## Step 1: Database Connection

Create `src/your_app/database.gleam`:

```gleam
import dream/services/service.{type DatabaseService, DatabaseService}
import envoy
import gleam/option.{None}
import pog

pub fn init_database() -> Result(DatabaseService, String) {
  // Get database URL from environment (or use default)
  let database_url =
    envoy.get("DATABASE_URL")
    |> result.unwrap("postgres://postgres:postgres@localhost:5434/dream_db")

  // Create connection pool configuration
  let config =
    pog.Config(
      ..pog.default_config(),
      host: "localhost",
      port: 5434,
      database: "dream_db",
      user: "postgres",
      password: None,
      pool_size: 15,
    )

  // Start the connection pool
  let db = pog.connect(config)

  Ok(DatabaseService(connection: db))
}
```

This creates a connection pool with 15 connections. The pool is managed by the BEAM—rock solid, battle-tested connection pooling.

## Step 2: Write Your SQL

Create `src/your_app/sql/list_users.sql`:

```sql
-- List all users
SELECT id, name, email, created_at 
FROM users 
ORDER BY id
```

Create `src/your_app/sql/get_user.sql`:

```sql
-- Get a single user by ID
SELECT id, name, email, created_at 
FROM users 
WHERE id = $1
```

Create `src/your_app/sql/create_user.sql`:

```sql
-- Create a new user
INSERT INTO users (name, email)
VALUES ($1, $2)
RETURNING id, name, email, created_at
```

Create `src/your_app/sql/update_user.sql`:

```sql
-- Update a user
UPDATE users
SET name = $1, email = $2
WHERE id = $3
RETURNING id, name, email, created_at
```

Create `src/your_app/sql/delete_user.sql`:

```sql
-- Delete a user
DELETE FROM users WHERE id = $1
```

Pure SQL. No ORM mapping. No magical annotations. Just SQL that does what it says.

## Step 3: Generate Type-Safe Functions

Run Squirrel to generate Gleam functions from your SQL:

```bash
gleam run -m squirrel
```

This creates `src/your_app/sql.gleam` with functions like:

```gleam
pub fn list_users(db: pog.Connection) -> Result(pog.Returned(ListUsersRow), pog.QueryError)
pub fn get_user(db: pog.Connection, id: Int) -> Result(pog.Returned(GetUserRow), pog.QueryError)
pub fn create_user(db: pog.Connection, name: String, email: String) -> Result(pog.Returned(CreateUserRow), pog.QueryError)
// ... etc
```

Each SQL file becomes a type-safe function. The parameters are inferred from your `$1`, `$2` placeholders. The return types are generated from your `SELECT` columns.

## Step 4: Create the Model

Create `src/your_app/models/user.gleam`:

```gleam
import dream/utilities/json/encoders
import examples/database/sql
import gleam/dynamic/decode
import gleam/json
import gleam/option
import gleam/time/timestamp
import pog

// Query functions - wrap Squirrel-generated SQL
pub fn list(db: pog.Connection) -> Result(pog.Returned(sql.ListUsersRow), pog.QueryError) {
  sql.list_users(db)
}

pub fn get(db: pog.Connection, id: Int) -> Result(pog.Returned(sql.GetUserRow), pog.QueryError) {
  sql.get_user(db, id)
}

pub fn create(
  db: pog.Connection,
  name: String,
  email: String,
) -> Result(pog.Returned(sql.CreateUserRow), pog.QueryError) {
  sql.create_user(db, name, email)
}

pub fn update(
  db: pog.Connection,
  id: Int,
  name: String,
  email: String,
) -> Result(pog.Returned(sql.UpdateUserRow), pog.QueryError) {
  sql.update_user(db, name, email, id)
}

pub fn delete(db: pog.Connection, id: Int) -> Result(pog.Returned(Nil), pog.QueryError) {
  sql.delete_user(db, id)
}

// Request decoder for JSON validation
pub fn decoder() -> decode.Decoder(#(String, String)) {
  use name <- decode.field("name", decode.string)
  use email <- decode.field("email", decode.string)
  decode.success(#(name, email))
}

// JSON encoders for different row types
pub fn encode(user: sql.GetUserRow) -> json.Json {
  encode_user_fields(user.id, user.name, user.email, user.created_at)
}

pub fn encode_list(user: sql.ListUsersRow) -> json.Json {
  encode_user_fields(user.id, user.name, user.email, user.created_at)
}

pub fn encode_create(user: sql.CreateUserRow) -> json.Json {
  encode_user_fields(user.id, user.name, user.email, user.created_at)
}

pub fn encode_update(user: sql.UpdateUserRow) -> json.Json {
  encode_user_fields(user.id, user.name, user.email, user.created_at)
}

// Shared encoder implementation (DRY principle)
fn encode_user_fields(
  id: Int,
  name: String,
  email: String,
  created_at: option.Option(timestamp.Timestamp),
) -> json.Json {
  json.object([
    #("id", json.int(id)),
    #("name", json.string(name)),
    #("email", json.string(email)),
    #("created_at", encoders.timestamp(created_at)),
  ])
}
```

The model wraps database operations and provides encoders/decoders. It returns `Result` types, never `Response` types. That's the controller's job.

## Step 5: Create the Controller

Create `src/your_app/controllers/users_controller.gleam`:

```gleam
import dream/core/http/transaction.{type Request, type Response, get_param}
import dream/services/postgres/response
import dream/validators/json_validator.{validate_or_respond}
import examples/database/context.{type DatabaseContext}
import examples/database/models/user
import examples/database/services.{type Services}
import gleam/int
import gleam/result

pub fn index(
  _request: Request,
  _context: DatabaseContext,
  services: Services,
) -> Response {
  let db = services.database.connection
  user.list(db) |> response.many_rows(user.encode_list)
}

pub fn show(
  request: Request,
  _context: DatabaseContext,
  services: Services,
) -> Response {
  let db = services.database.connection
  let assert Ok(id_str) = get_param(request, "id")
  let id = int.parse(id_str) |> result.unwrap(0)

  user.get(db, id) |> response.one_row(user.encode)
}

pub fn create(
  request: Request,
  _context: DatabaseContext,
  services: Services,
) -> Response {
  let db = services.database.connection

  case validate_or_respond(request.body, user.decoder()) {
    Error(response) -> response
    Ok(data) -> {
      let #(name, email) = data
      user.create(db, name, email) |> response.one_row(user.encode_create)
    }
  }
}

pub fn update(
  request: Request,
  _context: DatabaseContext,
  services: Services,
) -> Response {
  let db = services.database.connection
  let assert Ok(id_str) = get_param(request, "id")
  let id = int.parse(id_str) |> result.unwrap(0)

  case validate_or_respond(request.body, user.decoder()) {
    Error(response) -> response
    Ok(data) -> {
      let #(name, email) = data
      user.update(db, id, name, email) |> response.one_row(user.encode_update)
    }
  }
}

pub fn delete(
  request: Request,
  _context: DatabaseContext,
  services: Services,
) -> Response {
  let db = services.database.connection
  let assert Ok(id_str) = get_param(request, "id")
  let id = int.parse(id_str) |> result.unwrap(0)

  user.delete(db, id) |> response.success
}
```

Look at how clean these controllers are. Each one:
1. Extracts the database connection from services
2. Validates input if needed
3. Calls the model
4. Returns a response

The `response` helper functions do the heavy lifting:
- `response.many_rows()` - Returns JSON array or 500 on error
- `response.one_row()` - Returns JSON object, 404 if no rows, or 500 on error
- `response.success()` - Returns 200 on success, 500 on error

## Step 6: Wire Up Services

Create `src/your_app/services.gleam`:

```gleam
import dream/services/service.{type DatabaseService}
import your_app/database

pub type Services {
  Services(database: DatabaseService)
}

pub fn initialize_services() -> Services {
  let assert Ok(database_service) = database.init_database()
  Services(database: database_service)
}
```

Create `src/your_app/context.gleam`:

```gleam
pub type DatabaseContext {
  DatabaseContext(request_id: String)
}

pub fn context() -> DatabaseContext {
  DatabaseContext(request_id: "")
}
```

## Step 7: Create the Router

Create `src/your_app/router.gleam`:

```gleam
import dream/core/http/transaction.{Delete, Get, Post, Put}
import dream/core/router.{type Router, route, router}
import your_app/context.{type DatabaseContext}
import your_app/controllers/users_controller
import your_app/services.{type Services}

pub fn create_router() -> Router(DatabaseContext, Services) {
  router
  |> route(method: Get, path: "/users", controller: users_controller.index, middleware: [])
  |> route(method: Get, path: "/users/:id", controller: users_controller.show, middleware: [])
  |> route(method: Post, path: "/users", controller: users_controller.create, middleware: [])
  |> route(method: Put, path: "/users/:id", controller: users_controller.update, middleware: [])
  |> route(method: Delete, path: "/users/:id", controller: users_controller.delete, middleware: [])
}
```

Classic RESTful routes. Same path, different methods. Clean.

## Step 8: Update Main

Create `src/your_app/main.gleam`:

```gleam
import dream/servers/mist/server.{bind, context, listen, router, services} as dream
import your_app/context
import your_app/router.{create_router}
import your_app/services.{initialize_services}

pub fn main() {
  dream.new()
  |> context(context.context())
  |> services(initialize_services())
  |> router(create_router())
  |> bind("localhost")
  |> listen(3002)
}
```

## Step 9: Test It

Run your server:

```bash
gleam run
```

Test each endpoint:

```bash
# Create a user
curl -X POST http://localhost:3002/users \
  -H "Content-Type: application/json" \
  -d '{"name": "Alice", "email": "alice@example.com"}'
# Output: {"id": 1, "name": "Alice", "email": "alice@example.com", "created_at": "..."}

# List all users
curl http://localhost:3002/users
# Output: [{"id": 1, "name": "Alice", ...}]

# Get one user
curl http://localhost:3002/users/1
# Output: {"id": 1, "name": "Alice", ...}

# Update a user
curl -X PUT http://localhost:3002/users/1 \
  -H "Content-Type: application/json" \
  -d '{"name": "Alice Updated", "email": "alice.new@example.com"}'
# Output: {"id": 1, "name": "Alice Updated", ...}

# Delete a user
curl -X DELETE http://localhost:3002/users/1
# Output: (empty response with 200 status)
```

## How JSON Validation Works

The `validate_or_respond()` function is your friend:

```gleam
case validate_or_respond(request.body, user.decoder()) {
  Error(response) -> response  // Returns formatted error response
  Ok(data) -> {
    // Use the validated data
  }
}
```

If validation fails, it automatically returns a JSON error response:

```json
{
  "error": "Validation failed",
  "details": ["Field 'name' is required", "Field 'email' must be a string"]
}
```

Your decoder defines the shape:

```gleam
pub fn decoder() -> decode.Decoder(#(String, String)) {
  use name <- decode.field("name", decode.string)
  use email <- decode.field("email", decode.string)
  decode.success(#(name, email))
}
```

Type-safe validation with clear error messages. No guesswork.

## Three-Layer Architecture in Action

Notice how we split responsibilities:

**Layer 1: Controllers** (HTTP orchestration)
- Extract database from services
- Parse parameters
- Validate JSON
- Call models
- Return responses

**Layer 2: Models** (data operations)
- Wrap Squirrel SQL functions
- Provide decoders for validation
- Provide encoders for responses
- Return `Result` types

**Layer 3: Utilities** (framework helpers)
- `validate_or_respond()` - JSON validation
- `response.one_row()` - Result to Response conversion
- `encoders.timestamp()` - Common JSON encoding

This separation keeps each layer focused and testable.

## Response Helper Functions Explained

Dream provides helpers to convert database `Result` types to HTTP `Response` types:

```gleam
import dream/services/postgres/response

// For queries that return multiple rows
user.list(db) |> response.many_rows(user.encode_list)
// Returns: 200 with JSON array, or 500 on database error

// For queries that should return exactly one row
user.get(db, id) |> response.one_row(user.encode)
// Returns: 200 with JSON object, 404 if no rows, or 500 on error

// For commands that don't return data (DELETE, UPDATE without RETURNING)
user.delete(db, id) |> response.success
// Returns: 200 on success, 500 on error
```

These functions handle the tedious error cases so you don't have to write the same boilerplate in every controller.

## Why Separate Encoders?

You might wonder why we have `encode()`, `encode_list()`, `encode_create()`, etc.

Gleam has **nominal typing**. Even though `GetUserRow`, `ListUsersRow`, and `CreateUserRow` have the same fields, they're different types. You can't use one encoder for all.

The solution? Share the implementation:

```gleam
pub fn encode(user: sql.GetUserRow) -> json.Json {
  encode_user_fields(user.id, user.name, user.email, user.created_at)
}

pub fn encode_list(user: sql.ListUsersRow) -> json.Json {
  encode_user_fields(user.id, user.name, user.email, user.created_at)
}

fn encode_user_fields(id, name, email, created_at) -> json.Json {
  json.object([...])  // Actual encoding logic
}
```

Different public functions, same implementation. DRY principle respected.

## Common Patterns

### Handling Missing Records

```gleam
pub fn show(request, _context, services) -> Response {
  let db = services.database.connection
  let assert Ok(id_str) = get_param(request, "id")
  let id = int.parse(id_str) |> result.unwrap(0)

  case user.get(db, id) {
    Ok(returned) if list.length(returned.rows) > 0 -> {
      let assert [user_row] = returned.rows
      json_response(ok_status(), json.to_string(user.encode(user_row)))
    }
    Ok(_) -> text_response(not_found_status(), "User not found")
    Error(_) -> text_response(internal_server_error_status(), "Database error")
  }
}
```

Or use the helper (which does this for you):

```gleam
user.get(db, id) |> response.one_row(user.encode)
```

### Validation with Multiple Fields

```gleam
pub fn decoder() -> decode.Decoder(UserData) {
  use name <- decode.field("name", decode.string)
  use email <- decode.field("email", decode.string)
  use age <- decode.field("age", decode.int)
  use bio <- decode.optional_field("bio", decode.string)
  decode.success(UserData(name:, email:, age:, bio:))
}
```

### Transaction Support

For operations that need atomicity, use Pog's transaction support:

```gleam
import pog

pub fn transfer_money(db, from_id, to_id, amount) {
  pog.transaction(db, fn(tx) {
    use _ <- result.try(debit_account(tx, from_id, amount))
    use _ <- result.try(credit_account(tx, to_id, amount))
    Ok(Nil)
  })
}
```

## What's Next?

You've learned:
- ✅ How to set up PostgreSQL with Pog
- ✅ How to write SQL and generate type-safe functions with Squirrel
- ✅ How to create models that wrap database operations
- ✅ How to validate JSON requests
- ✅ How to convert Results to Responses
- ✅ The three-layer architecture in practice

**Ready for more?**

- [Tutorial: Authentication](authentication.md) - Custom context and middleware
- [Guide: Controllers and Models](../guides/controllers-and-models.md) - Deep dive
- [Guide: Database](../guides/database.md) - Advanced patterns

**Want to see the full example?**

Check out `src/examples/database/` in the Dream repository for the complete working code.

---

**[← Back: Basic Routing](basic-routing.md)** | **[Up: Documentation](../../README.md)** | **[Next: Authentication →](authentication.md)**

