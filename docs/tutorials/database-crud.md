# Tutorial: Database CRUD Operations

**Time:** 30 minutes  
**Prerequisites:** [Basic Routing](basic-routing.md) completed, PostgreSQL installed  
**Example code:** `examples/database/`

Time to connect to a real database. No ORM abstractions hiding what's happening. Just type-safe SQL queries that you can actually read.

We use [Squirrel](https://github.com/giacomocavalieri/squirrel) to generate type-safe Gleam functions from SQL files. You write SQL. Squirrel makes it type-safe. Dream stays out of your way.

## What We're Building

A REST API for users with full CRUD:
- `GET /users` - List all users
- `GET /users/:id` - Get one user
- `POST /users` - Create a user
- `PUT /users/:id` - Update a user
- `DELETE /users/:id` - Delete a user

With JSON validation, proper error handling, and type safety from database to JSON response.

## Prerequisites: Database Setup

First, start PostgreSQL:

```bash
make db-up
```

This starts PostgreSQL in Docker at `localhost:5434`. Run migrations:

```bash
make migrate
```

This creates your `users` table. Now let's build the API.

## Project Structure

```
src/
  your_app/
    controllers/
      users_controller.gleam
    models/
      user.gleam
    sql/
      list_users.sql
      get_user.sql
      create_user.sql
      update_user.sql
      delete_user.sql
    context.gleam
    database.gleam
    main.gleam
    router.gleam
    services.gleam
    sql.gleam  # Generated by Squirrel
```

## Step 1: Database Connection

Create `src/your_app/database.gleam`:

```gleam
import dream/services/service.{type DatabaseService, DatabaseService}
import envoy
import gleam/option.{None}
import pog

pub fn init_database() -> Result(DatabaseService, String) {
  // Get database URL from environment (or use default)
  let database_url =
    envoy.get("DATABASE_URL")
    |> result.unwrap("postgres://postgres:postgres@localhost:5434/dream_db")

  // Create connection pool configuration
  let config =
    pog.Config(
      ..pog.default_config(),
      host: "localhost",
      port: 5434,
      database: "dream_db",
      user: "postgres",
      password: None,
      pool_size: 15,
    )

  // Start the connection pool
  let db = pog.connect(config)

  Ok(DatabaseService(connection: db))
}
```

This creates a connection pool with 15 connections. The pool is managed by the BEAM—rock solid, battle-tested connection pooling.

## Step 2: Write Your SQL

Create `src/your_app/sql/list_users.sql`:

```sql
-- List all users
SELECT id, name, email, created_at 
FROM users 
ORDER BY id
```

Create `src/your_app/sql/get_user.sql`:

```sql
-- Get a single user by ID
SELECT id, name, email, created_at 
FROM users 
WHERE id = $1
```

Create `src/your_app/sql/create_user.sql`:

```sql
-- Create a new user
INSERT INTO users (name, email)
VALUES ($1, $2)
RETURNING id, name, email, created_at
```

Create `src/your_app/sql/update_user.sql`:

```sql
-- Update a user
UPDATE users
SET name = $1, email = $2
WHERE id = $3
RETURNING id, name, email, created_at
```

Create `src/your_app/sql/delete_user.sql`:

```sql
-- Delete a user
DELETE FROM users WHERE id = $1
```

Pure SQL. No ORM mapping. No magical annotations. Just SQL that does what it says.

## Step 3: Generate Type-Safe Functions

Run Squirrel to generate Gleam functions from your SQL:

```bash
gleam run -m squirrel
```

This creates `src/your_app/sql.gleam` with functions like:

```gleam
pub fn list_users(db: pog.Connection) -> Result(pog.Returned(ListUsersRow), pog.QueryError)
pub fn get_user(db: pog.Connection, id: Int) -> Result(pog.Returned(GetUserRow), pog.QueryError)
pub fn create_user(db: pog.Connection, name: String, email: String) -> Result(pog.Returned(CreateUserRow), pog.QueryError)
// ... etc
```

Each SQL file becomes a type-safe function. The parameters are inferred from your `$1`, `$2` placeholders. The return types are generated from your `SELECT` columns.

## Step 4: Create the Model

Create `src/your_app/models/user.gleam`:

```gleam
import dream/utilities/json/encoders
import sql
import gleam/dynamic/decode
import gleam/json
import gleam/option
import gleam/time/timestamp
import pog

// Query functions - wrap Squirrel-generated SQL
pub fn list(db: pog.Connection) -> Result(pog.Returned(sql.ListUsersRow), pog.QueryError) {
  sql.list_users(db)
}

pub fn get(db: pog.Connection, id: Int) -> Result(pog.Returned(sql.GetUserRow), pog.QueryError) {
  sql.get_user(db, id)
}

pub fn create(
  db: pog.Connection,
  name: String,
  email: String,
) -> Result(pog.Returned(sql.CreateUserRow), pog.QueryError) {
  sql.create_user(db, name, email)
}

pub fn update(
  db: pog.Connection,
  id: Int,
  name: String,
  email: String,
) -> Result(pog.Returned(sql.UpdateUserRow), pog.QueryError) {
  sql.update_user(db, name, email, id)
}

pub fn delete(db: pog.Connection, id: Int) -> Result(pog.Returned(Nil), pog.QueryError) {
  sql.delete_user(db, id)
}

// Request decoder for JSON validation
pub fn decoder() -> decode.Decoder(#(String, String)) {
  use name <- decode.field("name", decode.string)
  use email <- decode.field("email", decode.string)
  decode.success(#(name, email))
}

// JSON encoders for different row types
pub fn encode(user: sql.GetUserRow) -> json.Json {
  encode_user_fields(user.id, user.name, user.email, user.created_at)
}

pub fn encode_list(user: sql.ListUsersRow) -> json.Json {
  encode_user_fields(user.id, user.name, user.email, user.created_at)
}

pub fn encode_create(user: sql.CreateUserRow) -> json.Json {
  encode_user_fields(user.id, user.name, user.email, user.created_at)
}

pub fn encode_update(user: sql.UpdateUserRow) -> json.Json {
  encode_user_fields(user.id, user.name, user.email, user.created_at)
}

// Shared encoder implementation (DRY principle)
fn encode_user_fields(
  id: Int,
  name: String,
  email: String,
  created_at: option.Option(timestamp.Timestamp),
) -> json.Json {
  json.object([
    #("id", json.int(id)),
    #("name", json.string(name)),
    #("email", json.string(email)),
    #("created_at", encoders.timestamp(created_at)),
  ])
}
```

The model wraps database operations and provides input decoders for validation. It returns `Result` types, never `Response` types. Controllers orchestrate, views format responses.

## Step 5: Create the Controller

Create `src/your_app/controllers/users_controller.gleam`:

```gleam
import dream/core/http/transaction.{
  type Request, type Response, get_param,
}
import dream/validators/json_validator.{validate_or_respond}
import context.{type DatabaseContext}
import models/user
import views/user_view
import services.{type Services}

pub fn index(
  _request: Request,
  _context: DatabaseContext,
  services: Services,
) -> Response {
  let db = services.database.connection
  user.list(db)
  |> user_view.respond_list()
}

pub fn show(
  request: Request,
  _context: DatabaseContext,
  services: Services,
) -> Response {
  // Extract dependencies and path params first
  let assert Ok(param) = get_param(request, "id")
  let assert Ok(id) = param.as_int
  let db = services.database.connection

  user.get(db, id)
  |> user_view.respond()
}

pub fn create(
  request: Request,
  _context: DatabaseContext,
  services: Services,
) -> Response {
  // Extract dependencies first
  let db = services.database.connection
  
  case validate_or_respond(request.body, user.decoder()) {
    Error(response) -> response
    Ok(data) -> {
      let #(name, email) = data
      user.create(db, name, email)
      |> user_view.respond_created()
    }
  }
}

pub fn update(
  request: Request,
  _context: DatabaseContext,
  services: Services,
) -> Response {
  // Extract dependencies and path params first
  let assert Ok(param) = get_param(request, "id")
  let assert Ok(id) = param.as_int
  let db = services.database.connection

  case validate_or_respond(request.body, user.decoder()) {
    Error(response) -> response
    Ok(data) -> {
      let #(name, email) = data
      user.update(db, id, name, email)
      |> user_view.respond_updated()
    }
  }
}

pub fn delete(
  request: Request,
  _context: DatabaseContext,
  services: Services,
) -> Response {
  // Extract dependencies and path params first
  let assert Ok(param) = get_param(request, "id")
  let assert Ok(id) = param.as_int
  let db = services.database.connection

  user.delete(db, id)
  |> user_view.respond_deleted()
}
```

Look at how clean these controllers are. Each one:
1. Extracts path parameters with `let assert` (panics if missing—Dream's router guarantees they exist)
2. Extracts database connection from services
3. Validates request body if needed (for create/update)
4. Calls the model, uses `query.first_row()` or `query.all_rows()` to extract data
5. Handles errors (NotFound, DatabaseError), delegates to view for success

**Why `let assert` for path params?**
Dream's router only calls your controller if the path pattern matches. If `:id` is in your route,
it exists in the request. If it doesn't, that's a bug worth panicking over, not an error to handle gracefully.

## Step 6: Wire Up Services

Create `src/your_app/services.gleam`:

```gleam
import dream/services/service.{type DatabaseService}
import your_app/database

pub type Services {
  Services(database: DatabaseService)
}

pub fn initialize_services() -> Services {
  let assert Ok(database_service) = database.init_database()
  Services(database: database_service)
}
```

Create `src/your_app/context.gleam`:

```gleam
pub type DatabaseContext {
  DatabaseContext(request_id: String)
}

pub fn context() -> DatabaseContext {
  DatabaseContext(request_id: "")
}
```

## Step 7: Create the Router

Create `src/your_app/router.gleam`:

```gleam
import dream/core/http/transaction.{Delete, Get, Post, Put}
import dream/core/router.{type Router, route, router}
import your_app/context.{type DatabaseContext}
import your_app/controllers/users_controller
import your_app/services.{type Services}

pub fn create_router() -> Router(DatabaseContext, Services) {
  router
  |> route(method: Get, path: "/users", controller: users_controller.index, middleware: [])
  |> route(method: Get, path: "/users/:id", controller: users_controller.show, middleware: [])
  |> route(method: Post, path: "/users", controller: users_controller.create, middleware: [])
  |> route(method: Put, path: "/users/:id", controller: users_controller.update, middleware: [])
  |> route(method: Delete, path: "/users/:id", controller: users_controller.delete, middleware: [])
}
```

Classic RESTful routes. Same path, different methods. Clean.

## Step 8: Update Main

Create `src/your_app/main.gleam`:

```gleam
import dream/servers/mist/server.{bind, context, listen, router, services} as dream
import your_app/context
import your_app/router.{create_router}
import your_app/services.{initialize_services}

pub fn main() {
  dream.new()
  |> context(context.context())
  |> services(initialize_services())
  |> router(create_router())
  |> bind("localhost")
  |> listen(3002)
}
```

## Step 9: Test It

Run your server:

```bash
gleam run
```

Test each endpoint:

```bash
# Create a user
curl -X POST http://localhost:3002/users \
  -H "Content-Type: application/json" \
  -d '{"name": "Alice", "email": "alice@example.com"}'
# Output: {"id": 1, "name": "Alice", "email": "alice@example.com", "created_at": "..."}

# List all users
curl http://localhost:3002/users
# Output: [{"id": 1, "name": "Alice", ...}]

# Get one user
curl http://localhost:3002/users/1
# Output: {"id": 1, "name": "Alice", ...}

# Update a user
curl -X PUT http://localhost:3002/users/1 \
  -H "Content-Type: application/json" \
  -d '{"name": "Alice Updated", "email": "alice.new@example.com"}'
# Output: {"id": 1, "name": "Alice Updated", ...}

# Delete a user
curl -X DELETE http://localhost:3002/users/1
# Output: (empty response with 200 status)
```

## How JSON Validation Works

The `validate_or_respond()` function is your friend:

```gleam
case validate_or_respond(request.body, user.decoder()) {
  Error(response) -> response  // Returns formatted error response
  Ok(data) -> {
    // Use the validated data
  }
}
```

If validation fails, it automatically returns a JSON error response:

```json
{
  "error": "Validation failed",
  "details": ["Field 'name' is required", "Field 'email' must be a string"]
}
```

Your decoder defines the shape:

```gleam
pub fn decoder() -> decode.Decoder(#(String, String)) {
  use name <- decode.field("name", decode.string)
  use email <- decode.field("email", decode.string)
  decode.success(#(name, email))
}
```

Type-safe validation with clear error messages. No guesswork.

## Clean Layer Separation

Notice how we split responsibilities across four layers:

**Layer 1: Controllers** (HTTP orchestration)
- Extract dependencies (db from services)
- Parse path parameters
- Validate request bodies
- Call models for data
- Pass results to views for formatting

**Layer 2: Models** (data operations)
- Wrap Squirrel SQL functions
- Provide input decoders for validation
- Return `Result` types (never `Response` types)
- Handle business logic

**Layer 3: Views** (presentation)
- Domain-specific formatting (user → JSON, post → JSON)
- Receive `Result` types and unwrap them
- Success status codes (200, 201, etc.)
- Return `Response` types

**Shared errors view** (generic HTTP errors)
- 404 Not Found, 500 errors, 400 errors
- Reusable across all controllers

**Layer 4: Utilities** (framework helpers)
- `validate_or_respond()` - JSON validation with auto-formatted errors
- `query.first_row()` / `query.all_rows()` - Extract data from query results
- `encoders.timestamp()` / `encoders.optional_*()` - Common encoding patterns

Each layer has one job. No bleeding concerns across boundaries.

## View Layer Explained

Views receive `Result` types from models, unwrap them, and format responses. All JSON
encoding happens here—models never touch presentation logic.

### Domain-Specific Views

Each resource gets its own view for formatting:

```gleam
// views/user_view.gleam

import dream/utilities/json/encoders
import views/errors

/// Respond with a single user
pub fn respond(
  result: Result(pog.Returned(sql.GetUserRow), pog.QueryError),
) -> Response {
  case result {
    Ok(returned) -> respond_with_rows(returned.rows)
    Error(_) -> errors.internal_error()
  }
}

fn respond_with_rows(rows: List(sql.GetUserRow)) -> Response {
  case rows {
    [user] -> json_response(ok_status(), to_json(user))
    [] -> errors.not_found("User not found")
    _ -> errors.not_found("User not found")
  }
}

/// Respond with a list of users
pub fn respond_list(
  result: Result(pog.Returned(sql.ListUsersRow), pog.QueryError),
) -> Response {
  case result {
    Ok(returned) -> json_response(ok_status(), list_to_json(returned.rows))
    Error(_) -> errors.internal_error()
  }
}

// Private JSON encoding - all encoding logic in views

fn to_json(user: sql.GetUserRow) -> String {
  encode_user(user.id, user.name, user.email, user.created_at)
  |> json.to_string()
}

fn list_to_json(users: List(sql.ListUsersRow)) -> String {
  users
  |> list.map(fn(user) {
    encode_user(user.id, user.name, user.email, user.created_at)
  })
  |> json.array(from: _, of: fn(x) { x })
  |> json.to_string()
}

/// Shared encoder for all user row types
fn encode_user(
  id: Int,
  name: String,
  email: String,
  created_at: option.Option(timestamp.Timestamp),
) -> json.Json {
  json.object([
    #("id", json.int(id)),
    #("name", json.string(name)),
    #("email", json.string(email)),
    #("created_at", encoders.timestamp(created_at)),
  ])
}
```

### Shared Errors View

Generic HTTP errors live in one place, used by all domain views:

```gleam
// views/errors.gleam

/// 404 Not Found response
pub fn not_found(message: String) -> Response {
  json_response(not_found_status(), "{\"error\": \"" <> message <> "\"}")
}

/// 500 Internal Server Error response
pub fn internal_error() -> Response {
  json_response(
    internal_server_error_status(),
    "{\"error\": \"Internal server error\"}",
  )
}
```

**Key insight:** Domain views focus on formatting their data (users, posts, products).
Generic errors are shared. No duplication.

## Why Separate Encoders?

You might wonder why we have `encode()`, `encode_list()`, `encode_create()`, etc.

Gleam has **nominal typing**. Even though `GetUserRow`, `ListUsersRow`, and `CreateUserRow` have the same fields, they're different types. You can't use one encoder for all.

The solution? Share the implementation:

```gleam
pub fn encode(user: sql.GetUserRow) -> json.Json {
  encode_user_fields(user.id, user.name, user.email, user.created_at)
}

pub fn encode_list(user: sql.ListUsersRow) -> json.Json {
  encode_user_fields(user.id, user.name, user.email, user.created_at)
}

fn encode_user_fields(id, name, email, created_at) -> json.Json {
  json.object([...])  // Actual encoding logic
}
```

Each helper accepts a specific row type, but they all delegate to the same private encoder. DRY principle respected.

## Common Patterns

### Handling Missing Records

With the clean pattern, error handling is straightforward:

```gleam
pub fn show(request, _context, services) -> Response {
  // Extract dependencies at top
  let assert Ok(param) = get_param(request, "id")
  let assert Ok(id) = param.as_int
  let db = services.database.connection

  // Call model, delegate to view
  user.get(db, id)
  |> user_view.respond()
}
```

The view handles all the error cases using helper functions to avoid nested cases:

```gleam
// In views/user_view.gleam
pub fn respond(result: Result(pog.Returned(sql.GetUserRow), pog.QueryError)) -> Response {
  case result {
    Ok(returned) -> respond_with_rows(returned.rows)
    Error(_) -> errors.internal_error()
  }
}

fn respond_with_rows(rows: List(sql.GetUserRow)) -> Response {
  case rows {
    [user] -> json_response(ok_status(), to_json(user))
    [] -> errors.not_found("User not found")
    _ -> errors.not_found("User not found")
  }
}
```

Clean separation - controllers orchestrate, views handle the details. No nested cases.

### Validation with Multiple Fields

```gleam
pub fn decoder() -> decode.Decoder(UserData) {
  use name <- decode.field("name", decode.string)
  use email <- decode.field("email", decode.string)
  use age <- decode.field("age", decode.int)
  use bio <- decode.optional_field("bio", decode.string)
  decode.success(UserData(name:, email:, age:, bio:))
}
```

### Transaction Support

For operations that need atomicity, use Pog's transaction support:

```gleam
import pog

pub fn transfer_money(db, from_id, to_id, amount) {
  pog.transaction(db, fn(tx) {
    use _ <- result.try(debit_account(tx, from_id, amount))
    use _ <- result.try(credit_account(tx, to_id, amount))
    Ok(Nil)
  })
}
```

## What's Next?

You've learned:
- ✅ How to set up PostgreSQL with Pog
- ✅ How to write SQL and generate type-safe functions with Squirrel
- ✅ How to create models that wrap database operations
- ✅ How to validate JSON requests
- ✅ How to convert Results to Responses
- ✅ The three-layer architecture in practice

**Ready for more?**

- [Tutorial: Authentication](authentication.md) - Custom context and middleware
- [Guide: Controllers and Models](../guides/controllers-and-models.md) - Deep dive
- [Guide: Database](../guides/database.md) - Advanced patterns

**Want to see the full example?**

Check out `examples/database/` in the Dream repository for the complete working code.

---

**[← Back: Basic Routing](basic-routing.md)** | **[Up: Documentation](../../README.md)** | **[Next: Authentication →](authentication.md)**

